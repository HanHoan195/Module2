03/04
+ Kĩ thuật đổi tên biến và đổi tên phương thức: thay đổi tên biến hoặc phương thức để trở nên tốt hơn, dễ đọc có ý nghĩa tuân thủ coding convention
    -Cách đổi tên trong inteiJ: 1. Shift + f6 
                                2. Kích chuột phải ->refactor -> rename.  
 
+ Kĩ thuật tách biến: là kỹ thuật giúp đơn giản hóa các biểu thức và giúp dễ hiểu hơn
                      -Cách tách biến: kích chuột phải -> refactor ->Extract -> variable 
                      
+ Kĩ thuật tách hằng: -Trong nhiều trường hợp các giá trị " thần kỳ" (magic value) sẽ gây khó khăn cho việc đọc hiểu mã nguồn
                      -Tách hằng giúp mang lại ý nghĩa cho các giá trị thần kỳ và mã nguồn dễ hiểu hơn
                      -Cách tách hằng:  kích chuột phải -> refactor ->Extract -> constant
                      
+ kĩ thuật tách phương thức: -Một phương thức quá dài ,quá phức tạp hoặc xử lý quá nhiều tác vụ sẽ dẫn đến khó hiểu, khó kiểm soát
                             -Tách phương thức giúp cho các phương thức đọc dễ hiểu hơn, dễ kiểm soát hơn.
                             -Cách tách phương thức:  kích chuột phải -> refactor ->Extract -> method
                                
                                ----------------------------------------------------------------------
04/04

   * CÁC TÍNH CHẤT CỦA LẬP TRÌNH HƯỚNG ĐỐI TƯỢNG:
    
    +Tính đóng gói:
        - public class DehaCompany {
                 private long id;
                 private String fullName;
                 private Date birthDay;
                 private String phone;
                 private String email
    +Tính đa hình:
        -   Employee ep1 = new Experience
    
    +Tính trừu tượng:
        -public class Employee 
    
    +Tính kế thừa:
        - public class Experience extends Employee{
        - super(id, fullName, date, phone, email, type);
    
    +Override: 
    
            @Override
         public String toString() {
    
    +Overloangding: 
    
       - public Employee()
       - public Employee(long id, String fullName, Date birthDay, String phone, String email, EmployeeType employeeType) 
       
       
* SOLID:
 1. Single responsibility principle: Một class chỉ nên giữ 1 trách nhiệm duy nhất
        VD: public class ReportManager()
            {
               public void ReadDataFromDB();
               public void ProcessData();       // class này thực hiện ba nhiệm vụ nên tách ra ba class 
               public void PrintReport();
            }
2. Open/closed principle: -Có thể thoái mái mở rộng một class nhưng không đc sữa đổi bên trong class đó.
                          -Theo nguyên lý này mỗi khi ta muốn thêm chức năng cho chương trình chúng ta nên viết class mới mở rộng claass cũ 
                          bằng cách kế thừa hoặc sở hữu class cũ không nên sửa đổi class cũ.
                          
3. Liskov Substitution Principle: - Trong một chương trình các object của class con có thể thay thế class cha mà không lm thay đổi tính đúng đắn 
                                    của chương trình.
                                    
4. Interface Segregation Principle: Thay vì dùng một interface lớn ta nên tách nhiều ỉnterface nhỏ vs nhiều mục đích cụ thể.   

5. Dependency inversion principle: - Các module cấp cao không nên phụ thuộc vào module cấp thấp cả hai nên phụ thuộc vào abstraction.
                                   - Interface(abstract) không nên phụ thuộc vào chi tiết mà ngược lại .Các class giao tiếp vs nhau thông qua interface
                                   không phải thông qua implementation.

*TRY/CATCH

+ Ngoai lệ là gì:- Ngoại lệ trong Java là một đối tượng đại diện cho một lỗi hoặc một sự kiện bất ngờ xảy ra khi chương trình chạy và làm                   gián đoạn luồng thực thi bình thường của chương trình.
                 - Các loại Exception trong Java: 
                      + Checked Exception: Là loại exception xảy ra trong lúc compile time. Có thể kể đến như: IOException,                                                             SQLException,…
                      + Unchecked Exception: Các ngoại lệ không được kiểm tra tại thời điểm biên dịch, nhưng được kiểm tra trong thời                                                  gian chạy. Ví dụ như: ArithmeticException, NullPointerException, …
                      +  Error: Không thể khôi phục được. Như: OutOfMemoryError, VirtualMachineError,…
                      + Java cung cấp 5 từ khóa sử dụng để xử lý ngoại lệ đó là:
                           - try: Sử dụng để chứa đoạn lệnh có thể gây ra ngoại lệ, nó phải được theo sau bởi khối catch hoặc finally
                           - catch:	Sử dụng để xử lý ngoại lệ, các khối code để xử lý ngoại lệ sẽ được đặt trong đây
                           - finally: Sử dụng để thực thi đoạn mã cần thiết của chương trình. Khối này sẽ luôn được thực thi
                           - throw:	Sử dụng để ném ra ngoại lệ
                           - throws	Sử dụng để khai báo ngoại lệ

+ Xử lý ngoại lệ với try/catch:- Khi một ngoại lệ xảy ra, trình biên dịch tìm một khối catch phù hợp trong các khối catch đi kèm. Trình tự tìm là lần lượt từ khối thứ                                       nhất đến khối cuối cùng, khối catch đầu tiên bắt được ngoại lệ đó sẽ được thực thi.
    - Cú pháp: try{
                    //Khối lệnh có thể ném ra ngoại lệ
                }catch(<Exception_class_name> e){
                    //Code xử lý ngoại lệ
                }

+ Xử lý ngoại lệ với try/finally:- Phần try và phần catch trong khối try/catch là những phần bắt buộc phải có. Ngoài ra, ta còn có thể lắp một phần có tên finally vào                                          làm phần cuối cùng của khối try/catch.
                                 - Một khối finally là nơi ta đặt các đoạn mã phải được thực thi bất kể ngoại lệ có xảy ra hay không.
                                 
    - Cú pháp: try{
                    //Khối lệnh có thể ném ra ngoại lệ
                }finally{
                    //Khối lệnh trong đây luôn được thực thi
                }

+ Khối try/catch/finally:
    - Cú pháp: try{
                    //Khối lệnh có thể ném ra ngoại lệ
                }catch(<Exception_class_name_1> e){
                    //Code xử lý ngoại lệ 1
                }catch(<Exception_class_name_2> e){
                    //Code xử lý ngoại lệ 2
                }finally{
                    //Khối lệnh trong đây luôn được thực thi
                }
    

+ Các lệnh ném ngoại lệ: 
-Lệnh throw: Từ khóa throw được sử dụng để ném ra ngoại lệ cụ thể. Thông thường nó được sử dụng với exception do người dùng tự định nghĩa
    VD: System.out.println("Nhập tuổi của bạn:");
            age = sc.nextInt();
            //Tuổi không hợp lệ khi nhập số âm hoặc lớn hơn 200
            if(age < 0 || age > 200)
                throw new ArithmeticException("Tuổi không hợp lệ");

- Lệnh throws: Từ khóa throws sử dụng để khai báo ngoại lệ. Nó được sử dụng chủ yếu với checked exception
    VD: public void readFile() throws IOException{
                    // Khai báo ngoại lệ
                }
